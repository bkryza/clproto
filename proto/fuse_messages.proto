package veil.protocol.fuse_messages;

message ChannelRegistration {
    required string fuse_id = 1;
}

message ChannelClose {
    required string fuse_id = 1;
}

message FuseMessage {
    required string message_type = 1;
    required bytes input = 2;
}

message GetFileLocation {
    required string file_logic_name = 1;
}

message GetNewFileLocation {
    required string file_logic_name = 1;
    required uint32 mode = 2;
}

message GetFileAttr {
    required string file_logic_name = 1;
}

message FileAttr {
    optional string answer = 1 [default = "ok"];
    required int32 mode = 2;
    required int32 uid = 3;
    required int32 gid = 4;
    required int64 atime = 5;
    required int64 mtime = 6;
    required int64 ctime = 7;
    required string type = 9;
    optional int64 size = 10 [default = 0];
    optional string uname = 11 [default = ""];
    optional string gname = 12 [default = ""];
    optional int32 links = 13 [default = 1];
}

message FileLocation {
    optional string answer = 1 [default = "ok"];
    required int32 storage_id = 2;
    required string file_id = 3;
    required int32 validity = 4;
    optional string storage_helper_name = 5;
    repeated string storage_helper_args = 6;
}

message CreateFileAck {
    required string file_logic_name = 1;
}

message FileNotUsed {
    required string file_logic_name = 1;
}
 
message RenewFileLocation {
    required string file_logic_name = 1;
}

message FileLocationValidity {
    optional string answer = 1 [default = "ok"];
    optional int32 validity = 2;
}


message GetFileChildren {
    required string dir_logic_name = 1;
    required int32 children_num = 2;
    optional int32 offset = 3 [default = 0];
}

message FileChildren {
    optional string answer = 1 [default = "ok"];
    repeated string child_logic_name = 2;
}


message CreateDir {
    required string dir_logic_name = 1;
    required uint32 mode = 2;
}

message DeleteFile {
    required string file_logic_name = 1;
}

message CreateLink {
    required string from_file_logic_name = 1;
    required string to_file_logic_name = 2;
}

message GetLink {
    required string file_logic_name = 1;
}

message LinkInfo {
    optional string answer = 1 [default = "ok"];
    required string file_logic_name = 2;
}

message RenameFile {
    required string from_file_logic_name = 1;
    required string to_file_logic_name = 2;
}

message ChangeFileOwner {
    required string file_logic_name = 1;
    required int32 uid = 2;
    optional string uname = 4 [default = ""];
}

message ChangeFileGroup {
    required string file_logic_name = 1;
    required int32 gid = 3; 
    optional string gname = 5 [default = ""]; 
}

message ChangeFilePerms {
    required string file_logic_name = 1;
    required int32 perms = 2;
}

message UpdateTimes {
    required string file_logic_name = 1;
    optional int64 atime = 2 [default = -1];
    optional int64 mtime = 3 [default = -1];
    optional int64 ctime = 4 [default = -1];
}

message TestChannel {
    required string answer_message = 1;
    required int32 answer_delay_in_ms = 2;
}

message TestChannelAnswer {
    required string message = 1;
}

message HandshakeRequest {
    required string hostname = 1;

    message EnvVariable {
        required string name = 1;
        required string value = 2;
    }

    repeated EnvVariable variable = 2;
}

message HandshakeResponse {
    required string fuse_id = 1;
}

message HandshakeAck {
    required string fuse_id = 1;
}

message GetStatFS {}

message StatFSInfo {
    optional string answer = 1 [default = "ok"];
    required int64 quota_size = 2;
    required int64 files_size = 3;
}

message PushMessage{
    required string message_type = 1;
    optional bytes data = 2;
}


message EventFilterConfig {
    required string field_name = 1;
    required string desired_value = 2;
}

message EventAggregatorConfig {
    required string field_name = 1;
    required uint64 threshold = 2;
    required string sum_field_name = 3; // it will be extended in future. so far we assume that aggregation function is always sum and sum_field_name is field_name which values are summed
}

// EventStreamConfig is a message sent by cluster to client which contains informations needed for client to perform events processing (filtering, aggregation etc.)
// Only one of fields filter_config and aggregation_config is supposed to be set. Type of EventStreamConfig is determined by the fact which of those two fields is set.
//
// EventStreamConfig, EventFilterConfig, EventAggregatorConfig will be extended in future
//
// Example:
// Let assume we want to configure stream composed of two substreams: first we want to filter only messages with type "write_event" and then we want to group by filePath
// and send message on every 10th event
// EventStreamConfig{
//	wrapped_config: EventStreamConfig{
//		filter_config: EventFilterConfig{
//			field_name: "type",
//			desired_value: "write_event"
//		}
//	},
//	aggregator_config: EventAggregatorConfig{
//		field_name = "filePath",
//		threshold = 10,
//		sum_field_name = "count"
//	}
// }
// If we want message to be sent after 100 bytes has been written instead of every 10th event we need to change sum_field_name to "bytes" and threshold to 100

message EventStreamConfig {
    optional EventStreamConfig wrapped_config = 1;
    optional EventFilterConfig filter_config = 2;
    optional EventAggregatorConfig aggregator_config = 3;
}

message EventProducerConfig {
    repeated EventStreamConfig event_streams_configs = 1;
}

message EventMessage {
    required string type = 1;
    optional uint64 count = 2;
}
